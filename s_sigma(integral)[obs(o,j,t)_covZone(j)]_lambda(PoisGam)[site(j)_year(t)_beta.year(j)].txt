model{
    
    # PRIORS
    
    # Priors for lambda
    r ~ dunif(0,100) # Scale and shape from dgamma

    bYear.lam ~ dnorm(0, 0.001) # Prior for the trend

    for(j in 1:nsites){
    site[j] ~ dnorm(0, 0.001)   # Prior for site effects
    }

    for(t in 1:nyears){
    year[t] ~ dnorm(0, 0.001)   # Prior for year effects
    }
    

    # Priors for sigma
    bzB.sig ~ dnorm(0, 0.001)
    
    mu.sig ~ dunif(-10, 10) # Random effects for sigma per observer
    sig.sig ~ dunif(0, 10)
    tau.sig <- 1/(sig.sig*sig.sig)
    
    # Random observer effect for sigma
    for (o in 1:nobs){
    sig.obs[o] ~ dnorm(mu.sig, tau.sig)
    }
    
    for(i in 1:nind){
    dclass[i] ~ dcat(fct[site.dclass[i], year.dclass[i], 1:nG]) 
    }
    
    for(j in 1:nsites){ 

      for (t in 1:nyears){
    
      sigma[j,t] <- exp(sig.obs[ob[j,t]] + bzB.sig*zoneB[j])
    
      # Construct cell probabilities for nG multinomial cells (distance categories) PER SITE
    
        for(k in 1:nG){ 
    
          up[j,t,k]<-pnorm(db[k+1], 0, 1/sigma[j,t]^2) ##db are distance bin limits
          low[j,t,k]<-pnorm(db[k], 0, 1/sigma[j,t]^2) 
          p[j,t,k]<- 2 * (up[j,t,k] - low[j,t,k])
          pi[j,t,k] <- int.w[k] / strip.width 
          f[j,t,k]<- p[j,t,k]/f.0[j,t]/int.w[k]                   ## detection prob. in distance category k                      
          fc[j,t,k]<- f[j,t,k] * pi[j,t,k]                 ## pi=percent area of k; drops out if constant
          fct[j,t,k]<-fc[j,t,k]/pcap[j,t] 
          }
    
      pcap[j,t] <- sum(fc[j,t, 1:nG]) # Different per site and year (sum over all bins)
    
      f.0[j,t] <- 2 * dnorm(0,0, 1/sigma[j,t]^2) # Prob density at 0
    
    
      y[j,t] ~ dbin(pcap[j,t], N[j,t]) 
      N[j,t] ~ dpois(lambda.star[j,t]) 

      lambda[j,t] <- exp(site[j] + year[t] + bYear.lam*year1[t])
      rho[j,t] ~ dgamma(r,r) # Dispersion parameter
      lambda.star[j,t] <- rho[j,t]*lambda[j,t] # Lambda corrected by dispersion parameter
        }
      }
    
    # Derived parameters

    for(t in 1:nyears){
    popindex[t] <- sum(lambda.star[,t])
    }

    # Expected abundance per year inside model

    lam.star.tot[1] <- popindex[1] # Expected abundance in year 1
    for (i in 2:nyears){
      lam.star.tot[i] <- lam.star.tot[i-1] * # Here I add the starting population size as a baseline for the trend 
        exp(bYear.lam)}

    
    }
