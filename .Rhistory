# ---- Detection component ----
# RANDOM EFFECT IN OBSERVER
obs <- 1:9
nobs <- length(obs)
mu.sig.obs <- log(50)
sig.sig.obs <- 0.25
# Observer effect in sigma
sig.obs <- rnorm(length(obs), mu.sig.obs, sig.sig.obs)
# Observer covariate
ob.id <- matrix(sample(1:9, max.sites*nyrs, replace = TRUE), nrow = max.sites, ncol = nyrs) # Matix with IDs
ob <- matrix(sig.obs[ob.id],  nrow = max.sites, ncol = nyrs) # Matrix with intercept for simulating data
#ZONE COVARIATE (SITE)
b.sig.zoneB <- 0.7
# Site specific binary co-variate
z <- data.frame(var = sample(c("A", "B"), max.sites, replace = TRUE))
z$var <- as.factor(z$var)
zone <- model.matrix(~ var-1, z)
#SIGMA
sigma <- exp(ob + matrix(b.sig.zoneB*zone[,2], nrow = max.sites, ncol = nyrs, byrow = FALSE) )# HERE IT SHOULD BE FALSE :o!
# ----  Abundance component: random effect accross sites, zone covariate and 2 area covariates
# RANDOM EFFECT IN SITE (INDEPENDENT OF THE YEAR)
# Mean abundance and sd across sites
mu.lam.alpha.site <- log(1.5)
sig.lam.alpha.site <- 0.5
##Site effect in lambda
lam.alpha.site <- rnorm(max.sites, mu.lam.alpha.site, sig.lam.alpha.site)
#ZONE COVARIATE (SITE)
# Coefficient (I had created the co-variate already!So dont generate it twice!)
b.lam.zoneB <- -0.5
#AREA COVARIATE (SITE AND YEAR)
#Coefficients
b.a1 <- 0.9
b.a2 <- 1.2
#Covariates
a1 <- abs(rnorm(max.sites*nyrs, 10, 5)) # Although it makes sense to make them positive, it wouldnt matter (you put them on the exp)
a2 <- abs(rnorm(max.sites*nyrs, 5, 2.5))
#SCALED
area1_mean <- mean(a1)
area1_sd <- sd(a1)
area1_sc <- (a1 - area1_mean) / area1_sd
area2_mean <- mean(a2)
area2_sd <- sd(a2)
area2_sc <- (a2 - area2_mean) / area2_sd
lam <- exp(matrix(lam.alpha.site, nrow = max.sites, ncol = nyrs) +
matrix(b.lam.zoneB*zone[,2], nrow = max.sites, ncol = nyrs, byrow = F) + # By row has to be false for site covariates that dont change with year!
matrix(b.a1*area1_sc, nrow = max.sites, ncol = nyrs, byrow = F) + # For this it doesn't really matter
matrix(b.a2*area2_sc, nrow = max.sites, ncol = nyrs, byrow = F) )
# Abundance per site and year
N <- list()
for (t in 1:nyrs){
N[[t]] <- rpois(nSites[t],lam[1:nSites[t], t])
}
NLong <- ldply(N,cbind) # 1 long vector with all abundances per site and year
N3 <- ldply(N,rbind)
N.sitesYears <- t(N3) # N per site and year stored in a matrix with columns
# Total number of individuals in all sampled transects per year
N.tot <- lapply(N,sum)
# ---- Simulate continuous distance data ----
# Nc = count of individuals detected in each distance interval
yList <- list()
for (i in 1:nyrs){
yList[[i]] <- array(0, c(nSites[i], length(dist.breaks)-1))
}
for (t in 1:nyrs){
for(j in 1:max.sites) {
if(N.sitesYears[j,t] == 0 | is.na(N.sitesYears[j,t]))
next
# Distance from observer to the individual
d <- runif(N.sitesYears[j,t], 0, strip.width) 		# Uniform distribution of animals
# Simulates one distance for each individual in the site (N[j])
p <- g(x=d, sig=sigma[j,t])   		# Detection probability. Sigma is site-time specific
seen <- rbinom(N.sitesYears[j,t], 1, p)
if(all(seen == 0))
next
d1 <- d[seen==1] 				# The distance data for seen individuals
counts <- table(cut(d1, dist.breaks, include.lowest=TRUE))
yList[[t]][j,] <- counts 				# The number of detections in each distance interval
}}
y.sum.sites <- lapply(yList, function(x) rowSums(x)) # Total count per site each year
y.sum.sites2 <- ldply(y.sum.sites,rbind)
y.sum <- t(y.sum.sites2) # y per site and year stored in a matrix with columns
#############################################
# ---- Convert data to JAGS format ----
nind.year <- lapply(yList,sum)
nind <- sum(unlist(nind.year, use.names = F))
# Get one long vector with counts and sites
yLong.na <- unlist(as.data.frame(y.sum), use.names = F) # With NA included (useful if I ever make a model estimating abundance in sites with no information)
yLong <- yLong.na[complete.cases(yLong.na)]
sitesYears <- NULL
for (i in 1:nyrs){
sitesYears <- c(sitesYears,c(1:nSites[i]))
}
# Create one long vector with covariate values
a1.m <- matrix(area1_sc, nrow = max.sites, ncol = nyrs, byrow = F) # I need to make it from the same matrix
a2.m <- matrix(area2_sc, nrow = max.sites, ncol = nyrs, byrow = F)# from which I created lambda, to make it fit!
area1 <- NULL
for (i in 1:nyrs){
area1 <- c(area1,a1.m[1:nSites[i],i])
}
area2 <- NULL
for (i in 1:nyrs){
area2 <- c(area2,a2.m[1:nSites[i],i])
}
rm(list=ls())
library(rjags)
library(jagsUI)
library(plyr)
set.seed(2013)
# ---- Data simulation ----
#### Simulate abundance for one species:
#8 years (unbalanced number of transects per year); lambda site specific(Zone variable and 2 areas variables)
# Sigma site-year specific (effect of zone cov(?) and random effect in observer)
# Half-normal detection function
g <- function(x, sig) exp(-x^2/(2*sig^2))
# Number of transects per year (unbalanced)
nSites <- seq(50,106, by = 8)				# number of line transect surveys (DIFFERENT BY YEAR)
max.sites <- max(nSites)            # Maximun number of sites is the last year
strip.width <- 200 				# strip half-width, w (in this example only one side of the line transect is surveyed)
dist.breaks <- c(0,25,50,100,200)
int.w <- diff(dist.breaks) # width of distance categories (v)
midpt <- diff(dist.breaks)/2+dist.breaks[-5]
nG <- length(dist.breaks)-1
# Year effect
yrs <- 1:8 # eight years
nyrs <- length(yrs)
#################################
# ---- Detection component ----
# RANDOM EFFECT IN OBSERVER
obs <- 1:9
nobs <- length(obs)
mu.sig.obs <- log(50)
sig.sig.obs <- 0.25
# Observer effect in sigma
sig.obs <- rnorm(length(obs), mu.sig.obs, sig.sig.obs)
# Observer covariate
ob.id <- matrix(sample(1:9, max.sites*nyrs, replace = TRUE), nrow = max.sites, ncol = nyrs) # Matix with IDs
ob <- matrix(sig.obs[ob.id],  nrow = max.sites, ncol = nyrs) # Matrix with intercept for simulating data
#ZONE COVARIATE (SITE)
b.sig.zoneB <- 0.7
# Site specific binary co-variate
z <- data.frame(var = sample(c("A", "B"), max.sites, replace = TRUE))
z$var <- as.factor(z$var)
zone <- model.matrix(~ var-1, z)
#SIGMA
sigma <- exp(ob + matrix(b.sig.zoneB*zone[,2], nrow = max.sites, ncol = nyrs, byrow = FALSE) )# HERE IT SHOULD BE FALSE :o!
# ----  Abundance component: random effect accross sites, zone covariate and 2 area covariates
# RANDOM EFFECT IN SITE (INDEPENDENT OF THE YEAR)
# Mean abundance and sd across sites
mu.lam.alpha.site <- log(1.5)
sig.lam.alpha.site <- 0.5
##Site effect in lambda
lam.alpha.site <- rnorm(max.sites, mu.lam.alpha.site, sig.lam.alpha.site)
#ZONE COVARIATE (SITE)
# Coefficient (I had created the co-variate already!So dont generate it twice!)
b.lam.zoneB <- -0.5
#AREA COVARIATE (SITE AND YEAR)
#Coefficients
b.a1 <- 0.9
b.a2 <- 1.2
#Covariates
a1 <- abs(rnorm(max.sites*nyrs, 10, 5)) # Although it makes sense to make them positive, it wouldnt matter (you put them on the exp)
a2 <- abs(rnorm(max.sites*nyrs, 5, 2.5))
#SCALED
area1_mean <- mean(a1)
area1_sd <- sd(a1)
area1_sc <- (a1 - area1_mean) / area1_sd
area2_mean <- mean(a2)
area2_sd <- sd(a2)
area2_sc <- (a2 - area2_mean) / area2_sd
lam <- exp(matrix(lam.alpha.site, nrow = max.sites, ncol = nyrs) +
matrix(b.lam.zoneB*zone[,2], nrow = max.sites, ncol = nyrs, byrow = F) + # By row has to be false for site covariates that dont change with year!
matrix(b.a1*area1_sc, nrow = max.sites, ncol = nyrs, byrow = F) + # For this it doesn't really matter
matrix(b.a2*area2_sc, nrow = max.sites, ncol = nyrs, byrow = F) )
# Abundance per site and year
N <- list()
for (t in 1:nyrs){
N[[t]] <- rpois(nSites[t],lam[1:nSites[t], t])
}
NLong <- ldply(N,cbind) # 1 long vector with all abundances per site and year
N3 <- ldply(N,rbind)
N.sitesYears <- t(N3) # N per site and year stored in a matrix with columns
# Total number of individuals in all sampled transects per year
N.tot <- lapply(N,sum)
# ---- Simulate continuous distance data ----
# Nc = count of individuals detected in each distance interval
yList <- list()
for (i in 1:nyrs){
yList[[i]] <- array(0, c(nSites[i], length(dist.breaks)-1))
}
for (t in 1:nyrs){
for(j in 1:max.sites) {
if(N.sitesYears[j,t] == 0 | is.na(N.sitesYears[j,t]))
next
# Distance from observer to the individual
d <- runif(N.sitesYears[j,t], 0, strip.width) 		# Uniform distribution of animals
# Simulates one distance for each individual in the site (N[j])
p <- g(x=d, sig=sigma[j,t])   		# Detection probability. Sigma is site-time specific
seen <- rbinom(N.sitesYears[j,t], 1, p)
if(all(seen == 0))
next
d1 <- d[seen==1] 				# The distance data for seen individuals
counts <- table(cut(d1, dist.breaks, include.lowest=TRUE))
yList[[t]][j,] <- counts 				# The number of detections in each distance interval
}}
y.sum.sites <- lapply(yList, function(x) rowSums(x)) # Total count per site each year
y.sum.sites2 <- ldply(y.sum.sites,rbind)
y.sum <- t(y.sum.sites2) # y per site and year stored in a matrix with columns
#############################################
# ---- Convert data to JAGS format ----
nind.year <- lapply(yList,sum)
nind <- sum(unlist(nind.year, use.names = F))
# Get one long vector with counts and sites
yLong.na <- unlist(as.data.frame(y.sum), use.names = F) # With NA included (useful if I ever make a model estimating abundance in sites with no information)
yLong <- yLong.na[complete.cases(yLong.na)]
sitesYears <- NULL
for (i in 1:nyrs){
sitesYears <- c(sitesYears,c(1:nSites[i]))
}
# Create one long vector with covariate values
a1.m <- matrix(area1_sc, nrow = max.sites, ncol = nyrs, byrow = F) # I need to make it from the same matrix
a2.m <- matrix(area2_sc, nrow = max.sites, ncol = nyrs, byrow = F)# from which I created lambda, to make it fit!
area1 <- NULL
for (i in 1:nyrs){
area1 <- c(area1,a1.m[1:nSites[i],i])
}
area2 <- NULL
for (i in 1:nyrs){
area2 <- c(area2,a2.m[1:nSites[i],i])
}
zB <- as.vector(zone[,2])
zoneB <- NULL
for (i in 1:nyrs){
zoneB <- c(zoneB,zB[1:nSites[i]])
}
ob <- NULL
for (i in 1:nyrs){
ob <- c(ob,ob.id[1:nSites[i], i])
}
# Get one long vector with years, distance category and site
site <- dclass <- year <- NULL
for (t in 1:nyrs){
for(j in 1:max.sites){
if (y.sum[j,t] == 0 | is.na(y.sum[j,t]))
next
site <- c(site, rep(j, y.sum[j,t])) # site index: repeat the site as many times as counts in that site (for multi model??)
# vector of sites through years (disregarding distance class)
year <- c(year, rep(t, y.sum[j,t]))
for (k in 1:nG){
if (yList[[t]][j,k] == 0) # Refers for the ditance classes to the list with years and bins
next
dclass <- c(dclass, rep(k, yList[[t]][j,k]))	# Distance category index
}}
}
dclass
n.allSiteYear
nSites
n.allSiteYear <- sum(nSites)
#seq.allSiteYear <- 1:length(dclass)
siteYear.dclass <- NULL
n.allSiteYear
yLong
for (i in 1:n.allSiteYear){
siteYear.dclass <- c(siteYear.dclass,rep(i, yLong[i]))}
siteYear.dclass
allyears <- NULL
for (i in 1:nyrs){
allyears <- c(allyears,rep(yrs[i],nSites[i]))
}
m <- data.frame(allyears = allyears)
m$allyears <- as.factor(m$allyears)
indexYears <- model.matrix(~ allyears-1, data = m)
# Build occurrence probabilities in each cell depending on area outside jags because it complains
for(k in 1:nG){
pi[k] <- int.w[k] / strip.width }
rm(list=ls())
library(rjags)
library(jagsUI)
library(plyr)
set.seed(2013)
# Detection function
g <- function(x, sig) exp(-x^2/(2*sig^2))
# Number of transects per year (unbalanced)
nSites <- seq(50,106, by = 8)				# number of line transect surveys (DIFFERENT BY YEAR)
nSites
max.sites <- max(nSites)            # Maximun number of sites is the last year
total.sites <- sum(nSites)          # Total number of site-year combinations
total.sites
dist.breaks <- c(0,25,50,100,200)
int.w <- diff(dist.breaks) # width of distance categories (v)
midpt <- diff(dist.breaks)/2+dist.breaks[-5]
nG <- length(dist.breaks)-1
# Year effect
yrs <- 1:8 # eight years
nyrs <- length(yrs)
# Number of species
nSpecies <- 15
log(50)
log(2.5)
exp(2.5)
mu.sig.sp <- log(50)					# Mean of species-level random effect on intercept of sigma
sig.sig.sp <- 0.25				# SD of species-level random effect on intercept of sigma
s.alpha <- rnorm(nSpecies, mu.sig.sp, sig.sig.sp)
nSpecies
s.alpha <- rnorm(nSpecies, mu.sig.sp, sig.sig.sp)
s.alpha
# Look at distribution of sigma intercepts (to see if I chose reasonable)
hist(exp(rnorm(1000, mu.sig.sp, sig.sig.sp)))
# RANDOM EFFECT IN OBSERVER
obs <- 1:9
nobs <- length(obs)
sig.sig.obs <- 0.25
# Observer effect in sigma
sig.obs <- rnorm(length(obs), 0, sig.sig.obs) # Mean is 0 because is adding noise around the mean
sig.obs
max.sites*nyrs
# Observer covariate
ob.id <- matrix(sample(1:9, max.sites*nyrs, replace = TRUE), nrow = max.sites, ncol = nyrs) # Matix with IDs
ob.id
ob <- matrix(sig.obs[ob.id],  nrow = max.sites, ncol = nyrs) # Matrix with intercept for simulating data
ob
#ZONE COVARIATE (SITE)
b.sig.zoneB <- 0.7
# Site specific binary co-variate
z <- data.frame(var = sample(c("A", "B"), max.sites, replace = TRUE))
z$var <- as.factor(z$var)
zone <- model.matrix(~ var-1, z)
z
zone <- model.matrix(~ var-1, z)
zone
s.alpha
max.sites*nyrs
array(rep(s.alpha, each = max.sites*nyrs), c(max.sites, nyrs, nSpecies))
s.alpha
replicate(nSpecies,ob)
b.sig.zoneB*zone[,2]
array(b.sig.zoneB*zone[,2], c(max.sites,nyrs,nSpecies))
sigma <- exp(array(rep(s.alpha, each = max.sites*nyrs), c(max.sites, nyrs, nSpecies))
+ replicate(nSpecies,ob)
+ array(b.sig.zoneB*zone[,2], c(max.sites,nyrs,nSpecies)) )
sigma
# RANDOM EFFECT IN SITE (INDEPENDENT OF THE YEAR)
# Mean abundance and sd across sites
mu.lam.alpha.site <- log(1.5)
sig.lam.alpha.site <- 0.5
##Site effect in lambda
lam.alpha.site <- rnorm(max.sites, mu.lam.alpha.site, sig.lam.alpha.site)
#ZONE COVARIATE (SITE)
# Coefficient (I had created the co-variate already!So dont generate it twice!)
b.lam.zoneB <- -0.5
#AREA COVARIATE (SITE AND YEAR)
#Coefficients
b.a1 <- 0.9
b.a2 <- 1.2
#Covariates
a1 <- abs(rnorm(max.sites*nyrs, 10, 5)) # Although it makes sense to make them positive, it wouldnt matter (you put them on the exp)
a2 <- abs(rnorm(max.sites*nyrs, 5, 2.5))
#SCALED
area1_mean <- mean(a1)
area1_sd <- sd(a1)
area1_sc <- (a1 - area1_mean) / area1_sd
area2_mean <- mean(a2)
area2_sd <- sd(a2)
area2_sc <- (a2 - area2_mean) / area2_sd
lam <- exp(matrix(lam.alpha.site, nrow = max.sites, ncol = nyrs) +
matrix(b.lam.zoneB*zone[,2], nrow = max.sites, ncol = nyrs, byrow = F) + # By row has to be false for site covariates that dont change with year!
matrix(b.a1*area1_sc, nrow = max.sites, ncol = nyrs, byrow = F) + # For this it doesn't really matter
matrix(b.a2*area2_sc, nrow = max.sites, ncol = nyrs, byrow = F) )
# Abundance per site year (all species same abundance)
N <- list()
rm(list=ls())
library(dplyr)
library(stringr)
#setwd("C:/Users/ana.sanz/OneDrive/PhD/Second chapter/Data")
setwd("S:/PhD/Second chapter/Data")
dat1 <- read.csv("DataDS.csv", sep = ";")
dat1$Especie <- as.character(dat1$Especie)
dat1 <- dat1[ ,-4]
colnames(dat1)[which(colnames(dat1) == "Transecte_detall.Id_transecte_detall")] <- "Id_transecte_detall" # To make it equal to 2018
# Join with 2018.
# I have obtained DataDS2018 by exporting the modified questionary from 2018 because Nuria was sick
# Nuria has also sent me her version all together (DataDSALL_Nuria_2018.csv), and I have checked that the observations
# from 2018 are right. However, I still use DataDS and join it with DataDS2018 because I want to make sure
# that the observations from DataDS have the same order than before.
setwd("S:/PhD/Second chapter/Data")
dat18 <- read.csv("DataDS2018.csv", sep = ";")
dat18 <- dat18[ ,-c(2,15)] # To have the same columns than 2010 - 2017
dat <- rbind(dat1,dat18) # All data joined
f <- dat[which(dat$Any == "2018"), ]
# ---- Column names ----
names(dat)
colnames(dat)[which(colnames(dat) == "Id_transecte_detall")] <- "Sample.Label"
colnames(dat)[which(colnames(dat) == "Codi_seca")] <- "Region.Label"
colnames(dat)[which(colnames(dat) == "Any")] <- "Year"
colnames(dat)[which(colnames(dat) == "Especie")] <- "Species"
colnames(dat)[which(colnames(dat) == "Nombre")] <- "Count"
colnames(dat)[which(colnames(dat) == "Sexe")] <- "Sex"
colnames(dat)[which(colnames(dat) == "Us")] <- "Crop_type"
colnames(dat)[which(colnames(dat) == "Tipus_observacio")] <- "Obs_type"
colnames(dat)[which(colnames(dat) == "Hora_inici")] <- "Start_time"
colnames(dat)[which(colnames(dat) == "Observador")] <- "Observer"
colnames(dat)[which(colnames(dat) == "Vent")] <- "Wind"
colnames(dat)[which(colnames(dat) == "Nuvolositat")] <- "Clouds"
colnames(dat)[which(colnames(dat) == "Temperatura")] <- "Temp"
dat$Effort <- 500
# ----- Create variable transectID, than matches with the code of the GIS layers (i.e., two digits: 09) ----
#1. Add a 0 before the transect number
for (i in 1:nrow(dat)){
dat$Num_transecte[i] <- paste(0,dat$Num_transecte[i], sep = "")
}
#2. Keep only the last 2 digits (or 3 in the case of the transects that contain 100)
for (i in 1:nrow(dat)) {
cent <- substr(dat$Num_transecte[i], 4,4)
cent <- as.numeric(cent) # NA if it doesnt have 4 digits
if(is.na(cent)) { # if is NA (has 3 digits)
dat$Num_transecte[i] <- str_sub(dat$Num_transecte[i], start = -2) # Keep the last 2
} else { dat$Num_transecte[i] <- str_sub(dat$Num_transecte[i], start = -3)} # Otherwise, keep the last 3
}
# Create variable by pasting it
for (i in 1:nrow(dat)){
dat$transectID[i] <- paste(dat$Region.Label[i],dat$Num_transecte[i], sep = "")
}
# ---- Distance ----
setwd("S:/PhD/Second chapter/Data")
band <- read.csv("Banda.csv", sep = ";")
colnames(band)[1] <- "Banda"
dat <- left_join(dat, band, by = "Banda") # Joind bands (distbegin/distend)
dat <- dat[which(!is.na(dat$Banda)), ]
dat$distance <- NA # Medium point of each bin except in bin 4
for (i in 1:nrow(dat)){
if (dat$Banda[i] == 1) {dat$distance[i] = 12.5}
else if (dat$Banda[i] == 2) {dat$distance[i] = 37.5}
else if (dat$Banda[i] == 3) {dat$distance[i] = 75}
else  {dat$distance[i] = 150}
}
rm(list=ls())
library(dplyr)
library(stringr)
#setwd("C:/Users/ana.sanz/OneDrive/PhD/Second chapter/Data")
setwd("C:/Users/ana.sanz/Documents/PhD_20_sept/Second chapter/Data")
dat1 <- read.csv("DataDS.csv", sep = ";")
dat1$Especie <- as.character(dat1$Especie)
dat1 <- dat1[ ,-4]
colnames(dat1)[which(colnames(dat1) == "Transecte_detall.Id_transecte_detall")] <- "Id_transecte_detall" # To make it equal to 2018
# Join with 2018.
# I have obtained DataDS2018 by exporting the modified questionary from 2018 because Nuria was sick
# Nuria has also sent me her version all together (DataDSALL_Nuria_2018.csv), and I have checked that the observations
# from 2018 are right. However, I still use DataDS and join it with DataDS2018 because I want to make sure
# that the observations from DataDS have the same order than before.
setwd("S:/PhD/Second chapter/Data")
dat18 <- read.csv("DataDS2018.csv", sep = ";")
dat18 <- dat18[ ,-c(2,15)] # To have the same columns than 2010 - 2017
dat <- rbind(dat1,dat18) # All data joined
f <- dat[which(dat$Any == "2018"), ]
setwd("C:/Users/ana.sanz/Documents/PhD_20_sept/Second chapter/Data")
dat18 <- read.csv("DataDS2018.csv", sep = ";")
dat18 <- dat18[ ,-c(2,15)] # To have the same columns than 2010 - 2017
dat <- rbind(dat1,dat18) # All data joined
f <- dat[which(dat$Any == "2018"), ]
# ---- Column names ----
names(dat)
colnames(dat)[which(colnames(dat) == "Id_transecte_detall")] <- "Sample.Label"
colnames(dat)[which(colnames(dat) == "Codi_seca")] <- "Region.Label"
colnames(dat)[which(colnames(dat) == "Any")] <- "Year"
colnames(dat)[which(colnames(dat) == "Especie")] <- "Species"
colnames(dat)[which(colnames(dat) == "Nombre")] <- "Count"
colnames(dat)[which(colnames(dat) == "Sexe")] <- "Sex"
colnames(dat)[which(colnames(dat) == "Us")] <- "Crop_type"
colnames(dat)[which(colnames(dat) == "Tipus_observacio")] <- "Obs_type"
colnames(dat)[which(colnames(dat) == "Hora_inici")] <- "Start_time"
colnames(dat)[which(colnames(dat) == "Observador")] <- "Observer"
colnames(dat)[which(colnames(dat) == "Vent")] <- "Wind"
colnames(dat)[which(colnames(dat) == "Nuvolositat")] <- "Clouds"
colnames(dat)[which(colnames(dat) == "Temperatura")] <- "Temp"
dat$Effort <- 500
# ----- Create variable transectID, than matches with the code of the GIS layers (i.e., two digits: 09) ----
#1. Add a 0 before the transect number
for (i in 1:nrow(dat)){
dat$Num_transecte[i] <- paste(0,dat$Num_transecte[i], sep = "")
}
#2. Keep only the last 2 digits (or 3 in the case of the transects that contain 100)
for (i in 1:nrow(dat)) {
cent <- substr(dat$Num_transecte[i], 4,4)
cent <- as.numeric(cent) # NA if it doesnt have 4 digits
if(is.na(cent)) { # if is NA (has 3 digits)
dat$Num_transecte[i] <- str_sub(dat$Num_transecte[i], start = -2) # Keep the last 2
} else { dat$Num_transecte[i] <- str_sub(dat$Num_transecte[i], start = -3)} # Otherwise, keep the last 3
}
# Create variable by pasting it
for (i in 1:nrow(dat)){
dat$transectID[i] <- paste(dat$Region.Label[i],dat$Num_transecte[i], sep = "")
}
# ---- Distance ----
setwd("C:/Users/ana.sanz/Documents/PhD_20_sept/Second chapter/Data")
band <- read.csv("Banda.csv", sep = ";")
colnames(band)[1] <- "Banda"
dat <- left_join(dat, band, by = "Banda") # Joind bands (distbegin/distend)
dat <- dat[which(!is.na(dat$Banda)), ]
dat$distance <- NA # Medium point of each bin except in bin 4
for (i in 1:nrow(dat)){
if (dat$Banda[i] == 1) {dat$distance[i] = 12.5}
else if (dat$Banda[i] == 2) {dat$distance[i] = 37.5}
else if (dat$Banda[i] == 3) {dat$distance[i] = 75}
else  {dat$distance[i] = 150}
}
for (i in 1:nrow(dat)){
dat$T_Y[i] <- paste(dat$transectID[i],dat$Year[i], sep = "_")
}
dat$T_Y
trans <- dat[!duplicated(dat$Sample.Label), which(colnames(dat) %in% c("Sample.Label", "T_Y"))]
trans_rep <- trans[which(duplicated(trans$T_Y)), ]
trans_rep
View(dat)
